#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import type { Tool } from "@modelcontextprotocol/sdk/types.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import dotenv from "dotenv";
import { ConfluenceClient } from "./confluence-client.js";
import { DomAutoGeneratedHandler } from "./dom-auto-generated-handler.js";
import { logger } from "./logger.js";
import type { ConfluenceConfig } from "./types.js";

// 環境変数を読み込み
dotenv.config();

/**
 * MCP Confluence Server
 * Provides tools for reading and updating Confluence pages with auto-generated sections
 */
class ConfluenceMcpServer {
  private server: Server;
  private confluenceClient: ConfluenceClient | null = null;

  constructor() {
    this.server = new Server(
      {
        name: "confluence-mcp",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
        },
      },
    );

    this.setupToolHandlers();
    this.setupErrorHandling();
  }

  /**
   * ツールハンドラーの設定
   */
  private setupToolHandlers(): void {
    // ツール一覧の提供
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: "confluence_read",
            description: "Read auto-generated content from Confluence page",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
              },
              required: ["url"],
            },
          },
          {
            name: "confluence_update",
            description: "Update auto-generated content in Confluence page",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                content: {
                  type: "string",
                  description: "New content for auto-generated section",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
              },
              required: ["url", "content"],
            },
          },
          {
            name: "confluence_info",
            description: "Get Confluence page information",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
              },
              required: ["url"],
            },
          },
        ] as Tool[],
      };
    });

    // ツール実行ハンドラー
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      const startTime = Date.now();

      logger.toolStart(name, args || {});

      try {
        let result;
        switch (name) {
          case "confluence_read":
            result = await this.handleRead(args);
            break;
          case "confluence_update":
            result = await this.handleUpdate(args);
            break;
          case "confluence_info":
            result = await this.handleInfo(args);
            break;
          default:
            throw new Error(`Unknown tool: ${name}`);
        }

        const executionTime = Date.now() - startTime;
        logger.toolComplete(name, executionTime, result);
        return result;
      } catch (error) {
        const executionTime = Date.now() - startTime;
        const err = error instanceof Error ? error : new Error(String(error));
        logger.toolError(name, err, executionTime);

        return {
          content: [
            {
              type: "text",
              text: `Error: ${err.message}`,
            },
          ],
          isError: true,
        };
      }
    });
  }

  /**
   * エラーハンドリングの設定
   */
  private setupErrorHandling(): void {
    this.server.onerror = (error) => {
      logger.error(
        "MCP Server error",
        error instanceof Error ? error : new Error(String(error)),
      );
    };

    process.on("SIGINT", () => {
      logger.serverStop();
      process.exit(0);
    });

    process.on("SIGTERM", () => {
      logger.serverStop();
      process.exit(0);
    });
  }

  /**
   * Confluence設定を作成
   */
  private createConfig(url: string, email?: string): ConfluenceConfig {
    const apiToken = process.env.CONFLUENCE_API_TOKEN;
    if (!apiToken) {
      throw new Error("CONFLUENCE_API_TOKEN environment variable is required");
    }

    const userEmail = email || process.env.CONFLUENCE_EMAIL;
    if (!userEmail) {
      throw new Error(
        "Email is required. Set CONFLUENCE_EMAIL environment variable or provide email parameter",
      );
    }

    // URLからベースURLを抽出
    const urlObj = new URL(url);
    const baseUrl = `${urlObj.protocol}//${urlObj.hostname}`;

    return {
      baseUrl,
      email: userEmail,
      apiToken,
    };
  }

  /**
   * Confluenceクライアントを取得
   */
  private getConfluenceClient(config: ConfluenceConfig): ConfluenceClient {
    // 設定が変わった場合は新しいクライアントを作成
    if (
      !this.confluenceClient ||
      JSON.stringify(config) !== JSON.stringify(this.confluenceClient)
    ) {
      this.confluenceClient = new ConfluenceClient(config);
    }
    return this.confluenceClient;
  }

  /**
   * confluence_read ツールの処理
   */
  private async handleRead(args: any): Promise<any> {
    const { url, email } = args;

    if (!url || typeof url !== "string") {
      throw new Error("URL parameter is required and must be a string");
    }

    const config = this.createConfig(url, email);
    const client = this.getConfluenceClient(config);

    const pageId = ConfluenceClient.extractPageIdFromUrl(url);
    logger.pageOperation("read", pageId);

    const page = await client.getPage(pageId);
    logger.pageOperation("read", pageId, page.title);

    const content = page.body.storage.value;
    const hasMarkers = DomAutoGeneratedHandler.hasAutoGeneratedMarkers(content);

    if (!hasMarkers) {
      logger.warn(`Page does not contain auto-generated markers`, {
        pageId,
        pageTitle: page.title,
      });
      return {
        content: [
          {
            type: "text",
            text: `Page "${page.title}" does not contain auto-generated markers (BEGIN_AUTO_GENERATED/END_AUTO_GENERATED).`,
          },
        ],
      };
    }

    const autoGeneratedContent =
      DomAutoGeneratedHandler.getAutoGeneratedContent(content);
    logger.debug(`Extracted auto-generated content`, {
      pageId,
      contentLength: autoGeneratedContent.length,
    });

    return {
      content: [
        {
          type: "text",
          text: `Page: ${page.title}\\nPage ID: ${page.id}\\nVersion: ${page.version.number}\\n\\nAuto-generated content:\\n${autoGeneratedContent}`,
        },
      ],
    };
  }

  /**
   * confluence_update ツールの処理
   */
  private async handleUpdate(args: any): Promise<any> {
    const { url, content: newContent, email } = args;

    if (!url || typeof url !== "string") {
      throw new Error("URL parameter is required and must be a string");
    }

    if (!newContent || typeof newContent !== "string") {
      throw new Error("Content parameter is required and must be a string");
    }

    const config = this.createConfig(url, email);
    const client = this.getConfluenceClient(config);

    const pageId = ConfluenceClient.extractPageIdFromUrl(url);
    logger.pageOperation("update", pageId);

    const page = await client.getPage(pageId);
    logger.pageOperation("update", pageId, page.title);

    const originalContent = page.body.storage.value;
    const updatedContent = DomAutoGeneratedHandler.replaceAutoGeneratedSection(
      originalContent,
      newContent,
    );

    logger.debug(`Updating page content`, {
      pageId,
      pageTitle: page.title,
      originalVersion: page.version.number,
      newContentLength: newContent.length,
    });

    const updatedPage = await client.updatePage(
      pageId,
      page.title,
      updatedContent,
      page.version.number,
    );

    logger.info(`✅ Page updated successfully`, {
      pageId,
      pageTitle: page.title,
      oldVersion: page.version.number,
      newVersion: updatedPage.version.number,
    });

    return {
      content: [
        {
          type: "text",
          text: `Successfully updated page "${page.title}".\\nNew version: ${updatedPage.version.number}\\nUpdated content: ${newContent}`,
        },
      ],
    };
  }

  /**
   * confluence_info ツールの処理
   */
  private async handleInfo(args: any): Promise<any> {
    const { url, email } = args;

    if (!url || typeof url !== "string") {
      throw new Error("URL parameter is required and must be a string");
    }

    const config = this.createConfig(url, email);
    const client = this.getConfluenceClient(config);

    const pageId = ConfluenceClient.extractPageIdFromUrl(url);
    logger.pageOperation("info", pageId);

    const page = await client.getPage(pageId);
    const hasMarkers = DomAutoGeneratedHandler.hasAutoGeneratedMarkers(
      page.body.storage.value,
    );

    logger.debug(`Page info retrieved`, {
      pageId: page.id,
      pageTitle: page.title,
      version: page.version.number,
      hasMarkers,
    });

    return {
      content: [
        {
          type: "text",
          text: `Page Information:\\n  ID: ${page.id}\\n  Title: ${page.title}\\n  Version: ${page.version.number}\\n  Has auto-generated markers: ${hasMarkers}`,
        },
      ],
    };
  }

  /**
   * サーバーを開始
   */
  async start(): Promise<void> {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    logger.serverStart();
  }
}

// メイン実行
async function main(): Promise<void> {
  const server = new ConfluenceMcpServer();
  await server.start();
}

// ES modules用のmain実行チェック
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error("Failed to start MCP server:", error);
    process.exit(1);
  });
}

export { ConfluenceMcpServer };
