#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import type { Tool } from "@modelcontextprotocol/sdk/types.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import dotenv from "dotenv";
import { ConfluenceClient } from "./confluence-client.js";
import { CorrelationContext } from "./correlation.js";
import { DomAutoGeneratedHandler } from "./dom-auto-generated-handler.js";
import { ValidationError } from "./errors.js";
import { Logger, logger } from "./logger.js";
import { markdownConverter } from "./markdown-converter.js";
import { MarkdownExporter } from "./markdown-exporter.js";
import { MarkdownImporter } from "./markdown-importer.js";
import { StorageSyncManager } from "./storage-sync-manager.js";
import type { ConfluenceConfig, IOOptions } from "./types.js";

// 環境変数を読み込み
dotenv.config();

/**
 * MCP Confluence Server
 * Provides tools for reading and updating Confluence pages with auto-generated sections
 */
class ConfluenceMcpServer {
  private server: Server;
  private confluenceClient: ConfluenceClient | null = null;

  constructor() {
    this.server = new Server(
      {
        name: "confluence-mcp",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
        },
      },
    );

    this.setupToolHandlers();
    this.setupErrorHandling();
  }

  /**
   * ツールハンドラーの設定
   */
  private setupToolHandlers(): void {
    // ツール一覧の提供
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: "confluence_info",
            description: "Get Confluence page information",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
              },
              required: ["url"],
            },
          },
          {
            name: "confluence_read_as_markdown",
            description:
              "Read auto-generated content from Confluence page as Markdown format",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
              },
              required: ["url"],
            },
          },
          {
            name: "confluence_write_as_markdown",
            description:
              "Update auto-generated content in Confluence page with Markdown format",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                markdown: {
                  type: "string",
                  description:
                    "New content in Markdown format for auto-generated section",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
              },
              required: ["url", "markdown"],
            },
          },
          {
            name: "confluence_download_body",
            description:
              "Download Confluence page storage format (XHTML) to confluence-data directory without attachments.",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
                outputDir: {
                  type: "string",
                  description:
                    "Optional base directory for storage files (defaults to confluence-data)",
                },
                timeoutMs: {
                  type: "integer",
                  description: "Request timeout in milliseconds",
                },
              },
              required: ["url"],
            },
          },
          {
            name: "confluence_upload_body",
            description:
              "Upload Confluence page storage XHTML from confluence-data directory (attachments not modified).",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
                inputDir: {
                  type: "string",
                  description:
                    "Optional base directory for storage files (defaults to confluence-data)",
                },
                timeoutMs: {
                  type: "integer",
                  description: "Request timeout in milliseconds",
                },
              },
              required: ["url"],
            },
          },
          {
            name: "confluence_download_attachments",
            description:
              "Download attachments of a Confluence page to confluence-data directory.",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
                outputDir: {
                  type: "string",
                  description:
                    "Optional base directory for storage files (defaults to confluence-data)",
                },
                attachmentTitles: {
                  type: "array",
                  description:
                    "Optional list of attachment file names to download (others skipped)",
                  items: {
                    type: "string",
                  },
                },
                timeoutMs: {
                  type: "integer",
                  description: "Request timeout in milliseconds",
                },
              },
              required: ["url"],
            },
          },
          {
            name: "confluence_upload_attachments",
            description:
              "Upload attachments from confluence-data directory back to Confluence page.",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
                inputDir: {
                  type: "string",
                  description:
                    "Optional base directory for storage files (defaults to confluence-data)",
                },
                attachmentTitles: {
                  type: "array",
                  description:
                    "Optional list of attachment file names to upload (others skipped)",
                  items: {
                    type: "string",
                  },
                },
                timeoutMs: {
                  type: "integer",
                  description: "Request timeout in milliseconds",
                },
              },
              required: ["url"],
            },
          },
        ] as Tool[],
      };
    });

    // ツール実行ハンドラー
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      // Run with correlation context
      return CorrelationContext.run(async () => {
        const { name, arguments: args } = request.params;
        const startTime = Date.now();

        logger.info({
          event: "tool_execution",
          status: "started",
          tool: name,
          params: this.sanitizeParams(args || {}),
        });

        try {
          let result: any;
          switch (name) {
            case "confluence_info":
              result = await this.handleInfo(args);
              break;
            case "confluence_read_as_markdown":
              result = await this.handleReadAsMarkdown(args);
              break;
            case "confluence_write_as_markdown":
              result = await this.handleWriteAsMarkdown(args);
              break;
            case "confluence_download_body":
              result = await this.handleDownloadBody(args);
              break;
            case "confluence_upload_body":
              result = await this.handleUploadBody(args);
              break;
            case "confluence_download_attachments":
              result = await this.handleDownloadAttachments(args);
              break;
            case "confluence_upload_attachments":
              result = await this.handleUploadAttachments(args);
              break;
            default:
              throw new ValidationError("tool", `Unknown tool: ${name}`);
          }

          const durationMs = Date.now() - startTime;
          logger.info({
            event: "tool_execution",
            status: "completed",
            durationMs,
            tool: name,
            hasResult: !!result,
          });
          return result;
        } catch (error) {
          const durationMs = Date.now() - startTime;
          const err = error instanceof Error ? error : new Error(String(error));

          // Log error once at the top level
          logger.error({
            event: "tool_execution",
            status: "failed",
            durationMs,
            tool: name,
            error: Logger.serializeError(err),
          });

          return {
            content: [
              {
                type: "text",
                text: `Error: ${err.message}`,
              },
            ],
            isError: true,
          };
        }
      });
    });
  }

  /**
   * エラーハンドリングの設定
   */
  private setupErrorHandling(): void {
    this.server.onerror = (error) => {
      logger.error({
        event: "mcp_server_error",
        status: "failed",
        error: Logger.serializeError(error),
      });
    };

    const shutdown = async (signal: string) => {
      logger.info({
        event: "server_lifecycle",
        status: "shutting_down",
        action: "shutdown",
        reason: signal,
      });

      try {
        await this.stop();
        process.exit(0);
      } catch (error) {
        logger.error({
          event: "server_lifecycle",
          status: "failed",
          action: "shutdown",
          reason: signal,
          error: error instanceof Error ? error.message : String(error),
        });
        process.exit(1);
      }
    };

    process.on("SIGINT", () => {
      shutdown("SIGINT").catch((error) => {
        console.error("Shutdown error:", error);
        process.exit(1);
      });
    });

    process.on("SIGTERM", () => {
      shutdown("SIGTERM").catch((error) => {
        console.error("Shutdown error:", error);
        process.exit(1);
      });
    });

    process.on("uncaughtException", (error) => {
      logger.error({
        event: "uncaught_exception",
        status: "failed",
        error: Logger.serializeError(error),
      });
      shutdown("uncaughtException").catch(() => {
        process.exit(1);
      });
    });

    process.on("unhandledRejection", (reason) => {
      logger.error({
        event: "unhandled_rejection",
        status: "failed",
        reason: reason instanceof Error ? Logger.serializeError(reason) : String(reason),
      });
      shutdown("unhandledRejection").catch(() => {
        process.exit(1);
      });
    });
  }

  /**
   * パラメータから機密情報を除去
   */
  private sanitizeParams(params: Record<string, any>): Record<string, any> {
    const sanitized = { ...params };
    const sensitiveKeys = [
      "token",
      "password",
      "email",
      "apiToken",
      "api_token",
    ];

    for (const key of sensitiveKeys) {
      if (sanitized[key]) {
        sanitized[key] = "***MASKED***";
      }
    }

    return sanitized;
  }

  /**
   * Confluence設定を作成
   */
  private createConfig(url: string, email?: string): ConfluenceConfig {
    const apiToken = process.env.CONFLUENCE_API_TOKEN;
    if (!apiToken) {
      throw new ValidationError(
        "CONFLUENCE_API_TOKEN",
        "Environment variable is required",
      );
    }

    const userEmail = email || process.env.CONFLUENCE_EMAIL;
    if (!userEmail) {
      throw new ValidationError(
        "email",
        "Email is required. Set CONFLUENCE_EMAIL environment variable or provide email parameter",
      );
    }

    // URLからベースURLを抽出
    const urlObj = new URL(url);
    const baseUrl = `${urlObj.protocol}//${urlObj.hostname}`;

    return {
      baseUrl,
      email: userEmail,
      apiToken,
    };
  }

  /**
   * Confluenceクライアントを取得
   */
  private getConfluenceClient(config: ConfluenceConfig): ConfluenceClient {
    // 設定が変わった場合は新しいクライアントを作成
    if (
      !this.confluenceClient ||
      JSON.stringify(config) !== JSON.stringify(this.confluenceClient)
    ) {
      this.confluenceClient = new ConfluenceClient(config);
    }
    return this.confluenceClient;
  }

  /**
   * confluence_info ツールの処理
   */
  private async handleInfo(args: any): Promise<any> {
    const { url, email } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    const config = this.createConfig(url, email);
    const client = this.getConfluenceClient(config);

    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "page_operation",
      status: "started",
      operation: "info",
      target: `page/${pageId}`,
    });

    // Create IO options with default timeout
    const ioOptions: IOOptions = {
      timeoutMs: args.timeoutMs,
    };

    const page = await client.getPage(pageId, ioOptions);
    const hasMarkers = DomAutoGeneratedHandler.hasAutoGeneratedMarkers(
      page.body.storage.value,
    );

    logger.info({
      event: "page_operation",
      status: "completed",
      operation: "info",
      target: `page/${pageId}`,
      pageTitle: page.title,
      version: page.version.number,
      hasMarkers,
    });

    return {
      content: [
        {
          type: "text",
          text: `Page Information:\\n  ID: ${page.id}\\n  Title: ${page.title}\\n  Version: ${page.version.number}\\n  Has auto-generated markers: ${hasMarkers}`,
        },
      ],
    };
  }

  /**
   * confluence_read_as_markdown ツールの処理
   */
  private async handleReadAsMarkdown(args: any): Promise<any> {
    const { url, email } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    const config = this.createConfig(url, email);
    const client = this.getConfluenceClient(config);

    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "page_operation",
      status: "started",
      operation: "read_as_markdown",
      target: `page/${pageId}`,
    });

    // Create IO options with default timeout
    const ioOptions: IOOptions = {
      timeoutMs: args.timeoutMs,
    };

    const page = await client.getPage(pageId, ioOptions);

    logger.info({
      event: "page_operation",
      status: "completed",
      operation: "read_as_markdown",
      target: `page/${pageId}`,
      pageTitle: page.title,
    });

    const content = page.body.storage.value;
    const hasMarkers = DomAutoGeneratedHandler.hasAutoGeneratedMarkers(content);

    if (!hasMarkers) {
      logger.warn({
        event: "page_validation",
        status: "completed",
        target: `page/${pageId}`,
        pageTitle: page.title,
        issue: "no_auto_generated_markers",
      });
      return {
        content: [
          {
            type: "text",
            text: `Page "${page.title}" does not contain auto-generated markers (BEGIN_AUTO_GENERATED/END_AUTO_GENERATED).`,
          },
        ],
      };
    }

    const autoGeneratedContent =
      DomAutoGeneratedHandler.getAutoGeneratedContent(content);

    // Convert Storage Format to Markdown
    const markdown = markdownConverter.toMarkdown(autoGeneratedContent);

    logger.debug({
      event: "content_extraction",
      status: "completed",
      target: `page/${pageId}`,
      contentLength: markdown.length,
    });

    return {
      content: [
        {
          type: "text",
          text: `Page: ${page.title}\\nPage ID: ${page.id}\\nVersion: ${page.version.number}\\n\\nAuto-generated content (Markdown):\\n${markdown}`,
        },
      ],
    };
  }

  /**
   * confluence_write_as_markdown ツールの処理
   */
  private async handleWriteAsMarkdown(args: any): Promise<any> {
    const { url, markdown, email } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    if (!markdown || typeof markdown !== "string") {
      throw new ValidationError(
        "markdown",
        "Markdown parameter is required and must be a string",
      );
    }

    const config = this.createConfig(url, email);
    const client = this.getConfluenceClient(config);

    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "page_operation",
      status: "started",
      operation: "write_as_markdown",
      target: `page/${pageId}`,
    });

    // Create IO options with default timeout
    const ioOptions: IOOptions = {
      timeoutMs: args.timeoutMs,
    };

    const page = await client.getPage(pageId, ioOptions);

    // Convert Markdown to Storage Format
    const storageContent = markdownConverter.toStorageFormat(markdown);

    const originalContent = page.body.storage.value;
    const updatedContent = DomAutoGeneratedHandler.replaceAutoGeneratedSection(
      originalContent,
      storageContent,
    );

    logger.debug({
      event: "content_preparation",
      status: "completed",
      target: `page/${pageId}`,
      pageTitle: page.title,
      originalVersion: page.version.number,
      markdownLength: markdown.length,
    });

    const updatedPage = await client.updatePage(
      pageId,
      page.title,
      updatedContent,
      page.version.number,
      ioOptions,
    );

    logger.info({
      event: "page_operation",
      status: "completed",
      operation: "write_as_markdown",
      target: `page/${pageId}`,
      pageTitle: page.title,
      oldVersion: page.version.number,
      newVersion: updatedPage.version.number,
    });

    return {
      content: [
        {
          type: "text",
          text: `Successfully updated page "${page.title}".\\nNew version: ${updatedPage.version.number}\\nUpdated content (Markdown):\\n${markdown}`,
        },
      ],
    };
  }

  /**
   * サーバーを開始
   */
  async start(): Promise<void> {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);

    logger.info({
      event: "server_lifecycle",
      status: "started",
      action: "startup",
      version: "1.0.0",
    });
  }

  /**
   * サーバーを停止
   */
  async stop(): Promise<void> {
    try {
      await this.server.close();
      logger.info({
        event: "server_lifecycle",
        status: "completed",
        action: "shutdown",
      });
    } catch (error) {
      logger.error({
        event: "server_lifecycle",
        status: "failed",
        action: "shutdown",
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  private async handleDownloadBody(args: any): Promise<any> {
    const { url, email, outputDir } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    const config = this.createConfig(url, email);
    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "body_download",
      status: "started",
      target: `page/${pageId}`,
      outputDir,
    });

    const syncManager = new StorageSyncManager(config);
    const result = await syncManager.downloadBody({
      pageUrl: url,
      outputDir,
      options: {
        timeoutMs: args.timeoutMs,
      },
    });

    logger.info({
      event: "body_download",
      status: result.skipped ? "skipped" : "completed",
      target: `page/${pageId}`,
      skipped: result.skipped,
    });

    const logLines = result.logFiles.map((entry) => `  - ${entry}`).join("\n");

    return {
      content: [
        {
          type: "text",
          text: `Body download completed for page ${pageId}.\nSkipped: ${result.skipped}\nPage file: ${result.pageFile}\nMeta file: ${result.metaFile}\nLog files:\n${logLines}`,
        },
      ],
    };
  }

  private async handleUploadBody(args: any): Promise<any> {
    const { url, email, inputDir } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    const config = this.createConfig(url, email);
    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "body_upload",
      status: "started",
      target: `page/${pageId}`,
      inputDir,
    });

    const syncManager = new StorageSyncManager(config);
    const result = await syncManager.uploadBody({
      pageUrl: url,
      inputDir,
      options: {
        timeoutMs: args.timeoutMs,
      },
    });

    logger.info({
      event: "body_upload",
      status: "completed",
      target: `page/${pageId}`,
      pageUpdated: result.pageUpdated,
    });

    const logLines = result.logFiles.map((entry) => `  - ${entry}`).join("\n");

    return {
      content: [
        {
          type: "text",
          text: `Body upload completed for page ${pageId}.\nPage updated: ${result.pageUpdated}\nMeta file: ${result.metaFile}\nLog files:\n${logLines}`,
        },
      ],
    };
  }

  private async handleDownloadAttachments(args: any): Promise<any> {
    const { url, email, outputDir, attachmentTitles } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    if (attachmentTitles && !Array.isArray(attachmentTitles)) {
      throw new ValidationError(
        "attachmentTitles",
        "attachmentTitles must be an array of strings",
      );
    }

    const config = this.createConfig(url, email);
    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "attachments_download",
      status: "started",
      target: `page/${pageId}`,
      outputDir,
      filterCount: attachmentTitles?.length ?? 0,
    });

    const syncManager = new StorageSyncManager(config);
    const downloadParams: {
      pageUrl: string;
      outputDir: any;
      attachmentFilter?: { includeTitles: string[] };
      options: { timeoutMs: any };
    } = {
      pageUrl: url,
      outputDir,
      options: {
        timeoutMs: args.timeoutMs,
      },
    };
    if (attachmentTitles) {
      downloadParams.attachmentFilter = { includeTitles: attachmentTitles as string[] };
    }
    const result = await syncManager.downloadAttachments(downloadParams);

    logger.info({
      event: "attachments_download",
      status: "completed",
      target: `page/${pageId}`,
      downloaded: result.downloaded.length,
      skipped: result.skipped.length,
      removed: result.removed.length,
    });

    const logLines = result.logFiles.map((entry) => `  - ${entry}`).join("\n");

    return {
      content: [
        {
          type: "text",
          text: `Attachments download completed for page ${pageId}.\nDownloaded: ${result.downloaded.join(", ") || "none"}\nSkipped: ${result.skipped.join(", ") || "none"}\nRemoved: ${result.removed.join(", ") || "none"}\nMeta file: ${result.metaFile}\nLog files:\n${logLines}`,
        },
      ],
    };
  }

  private async handleUploadAttachments(args: any): Promise<any> {
    const { url, email, inputDir, attachmentTitles } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    if (attachmentTitles && !Array.isArray(attachmentTitles)) {
      throw new ValidationError(
        "attachmentTitles",
        "attachmentTitles must be an array of strings",
      );
    }

    const config = this.createConfig(url, email);
    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "attachments_upload",
      status: "started",
      target: `page/${pageId}`,
      inputDir,
      filterCount: attachmentTitles?.length ?? 0,
    });

    const syncManager = new StorageSyncManager(config);
    const uploadParams: {
      pageUrl: string;
      inputDir: any;
      attachmentFilter?: { includeTitles: string[] };
      options: { timeoutMs: any };
    } = {
      pageUrl: url,
      inputDir,
      options: {
        timeoutMs: args.timeoutMs,
      },
    };
    if (attachmentTitles) {
      uploadParams.attachmentFilter = { includeTitles: attachmentTitles as string[] };
    }
    const result = await syncManager.uploadAttachments(uploadParams);

    logger.info({
      event: "attachments_upload",
      status: "completed",
      target: `page/${pageId}`,
      uploaded: result.uploaded.length,
      skipped: result.skipped.length,
    });

    const logLines = result.logFiles.map((entry) => `  - ${entry}`).join("\n");

    return {
      content: [
        {
          type: "text",
          text: `Attachments upload completed for page ${pageId}.\nUploaded: ${result.uploaded.join(", ") || "none"}\nSkipped: ${result.skipped.join(", ") || "none"}\nMeta file: ${result.metaFile}\nLog files:\n${logLines}`,
        },
      ],
    };
  }
}

// メイン実行
async function main(): Promise<void> {
  try {
    const server = new ConfluenceMcpServer();
    await server.start();

    // サーバーは無期限に実行される
    // シグナルハンドラーが終了を管理
  } catch (error) {
    logger.error({
      event: "server_lifecycle",
      status: "failed",
      action: "startup",
      error: error instanceof Error ? Logger.serializeError(error) : String(error),
    });
    throw error;
  }
}

// ES modules用のmain実行チェック
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error("Failed to start MCP server:", error);
    process.exit(1);
  });
}

export { ConfluenceMcpServer };
