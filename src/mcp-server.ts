#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import type { Tool } from "@modelcontextprotocol/sdk/types.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import dotenv from "dotenv";
import { ConfluenceClient } from "./confluence-client.js";
import { CorrelationContext } from "./correlation.js";
import { DomAutoGeneratedHandler } from "./dom-auto-generated-handler.js";
import { ValidationError } from "./errors.js";
import { Logger, logger } from "./logger.js";
import type { ConfluenceConfig, IOOptions } from "./types.js";

// 環境変数を読み込み
dotenv.config();

/**
 * MCP Confluence Server
 * Provides tools for reading and updating Confluence pages with auto-generated sections
 */
class ConfluenceMcpServer {
  private server: Server;
  private confluenceClient: ConfluenceClient | null = null;

  constructor() {
    this.server = new Server(
      {
        name: "confluence-mcp",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
        },
      },
    );

    this.setupToolHandlers();
    this.setupErrorHandling();
  }

  /**
   * ツールハンドラーの設定
   */
  private setupToolHandlers(): void {
    // ツール一覧の提供
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: "confluence_read",
            description: "Read auto-generated content from Confluence page",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
              },
              required: ["url"],
            },
          },
          {
            name: "confluence_update",
            description: "Update auto-generated content in Confluence page",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                content: {
                  type: "string",
                  description: "New content for auto-generated section",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
              },
              required: ["url", "content"],
            },
          },
          {
            name: "confluence_info",
            description: "Get Confluence page information",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Confluence page URL",
                },
                email: {
                  type: "string",
                  description:
                    "User email for authentication (optional if CONFLUENCE_EMAIL env var is set)",
                },
              },
              required: ["url"],
            },
          },
        ] as Tool[],
      };
    });

    // ツール実行ハンドラー
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      // Run with correlation context
      return CorrelationContext.run(async () => {
        const { name, arguments: args } = request.params;
        const startTime = Date.now();

        logger.info({
          event: "tool_execution",
          status: "started",
          tool: name,
          params: this.sanitizeParams(args || {}),
        });

        try {
          let result: any;
          switch (name) {
            case "confluence_read":
              result = await this.handleRead(args);
              break;
            case "confluence_update":
              result = await this.handleUpdate(args);
              break;
            case "confluence_info":
              result = await this.handleInfo(args);
              break;
            default:
              throw new ValidationError("tool", `Unknown tool: ${name}`);
          }

          const durationMs = Date.now() - startTime;
          logger.info({
            event: "tool_execution",
            status: "completed",
            durationMs,
            tool: name,
            hasResult: !!result,
          });
          return result;
        } catch (error) {
          const durationMs = Date.now() - startTime;
          const err = error instanceof Error ? error : new Error(String(error));

          // Log error once at the top level
          logger.error({
            event: "tool_execution",
            status: "failed",
            durationMs,
            tool: name,
            error: Logger.serializeError(err),
          });

          return {
            content: [
              {
                type: "text",
                text: `Error: ${err.message}`,
              },
            ],
            isError: true,
          };
        }
      });
    });
  }

  /**
   * エラーハンドリングの設定
   */
  private setupErrorHandling(): void {
    this.server.onerror = (error) => {
      logger.error({
        event: "mcp_server_error",
        status: "failed",
        error: Logger.serializeError(error),
      });
    };

    process.on("SIGINT", () => {
      logger.info({
        event: "server_lifecycle",
        status: "completed",
        action: "shutdown",
        reason: "SIGINT",
      });
      process.exit(0);
    });

    process.on("SIGTERM", () => {
      logger.info({
        event: "server_lifecycle",
        status: "completed",
        action: "shutdown",
        reason: "SIGTERM",
      });
      process.exit(0);
    });
  }

  /**
   * パラメータから機密情報を除去
   */
  private sanitizeParams(params: Record<string, any>): Record<string, any> {
    const sanitized = { ...params };
    const sensitiveKeys = [
      "token",
      "password",
      "email",
      "apiToken",
      "api_token",
    ];

    for (const key of sensitiveKeys) {
      if (sanitized[key]) {
        sanitized[key] = "***MASKED***";
      }
    }

    return sanitized;
  }

  /**
   * Confluence設定を作成
   */
  private createConfig(url: string, email?: string): ConfluenceConfig {
    const apiToken = process.env.CONFLUENCE_API_TOKEN;
    if (!apiToken) {
      throw new ValidationError(
        "CONFLUENCE_API_TOKEN",
        "Environment variable is required",
      );
    }

    const userEmail = email || process.env.CONFLUENCE_EMAIL;
    if (!userEmail) {
      throw new ValidationError(
        "email",
        "Email is required. Set CONFLUENCE_EMAIL environment variable or provide email parameter",
      );
    }

    // URLからベースURLを抽出
    const urlObj = new URL(url);
    const baseUrl = `${urlObj.protocol}//${urlObj.hostname}`;

    return {
      baseUrl,
      email: userEmail,
      apiToken,
    };
  }

  /**
   * Confluenceクライアントを取得
   */
  private getConfluenceClient(config: ConfluenceConfig): ConfluenceClient {
    // 設定が変わった場合は新しいクライアントを作成
    if (
      !this.confluenceClient ||
      JSON.stringify(config) !== JSON.stringify(this.confluenceClient)
    ) {
      this.confluenceClient = new ConfluenceClient(config);
    }
    return this.confluenceClient;
  }

  /**
   * confluence_read ツールの処理
   */
  private async handleRead(args: any): Promise<any> {
    const { url, email } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    const config = this.createConfig(url, email);
    const client = this.getConfluenceClient(config);

    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "page_operation",
      status: "started",
      operation: "read",
      target: `page/${pageId}`,
    });

    // Create IO options with default timeout
    const ioOptions: IOOptions = {
      timeoutMs: args.timeoutMs,
    };

    const page = await client.getPage(pageId, ioOptions);

    logger.info({
      event: "page_operation",
      status: "completed",
      operation: "read",
      target: `page/${pageId}`,
      pageTitle: page.title,
    });

    const content = page.body.storage.value;
    const hasMarkers = DomAutoGeneratedHandler.hasAutoGeneratedMarkers(content);

    if (!hasMarkers) {
      logger.warn({
        event: "page_validation",
        status: "completed",
        target: `page/${pageId}`,
        pageTitle: page.title,
        issue: "no_auto_generated_markers",
      });
      return {
        content: [
          {
            type: "text",
            text: `Page "${page.title}" does not contain auto-generated markers (BEGIN_AUTO_GENERATED/END_AUTO_GENERATED).`,
          },
        ],
      };
    }

    const autoGeneratedContent =
      DomAutoGeneratedHandler.getAutoGeneratedContent(content);

    logger.debug({
      event: "content_extraction",
      status: "completed",
      target: `page/${pageId}`,
      contentLength: autoGeneratedContent.length,
    });

    return {
      content: [
        {
          type: "text",
          text: `Page: ${page.title}\\nPage ID: ${page.id}\\nVersion: ${page.version.number}\\n\\nAuto-generated content:\\n${autoGeneratedContent}`,
        },
      ],
    };
  }

  /**
   * confluence_update ツールの処理
   */
  private async handleUpdate(args: any): Promise<any> {
    const { url, content: newContent, email } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    if (!newContent || typeof newContent !== "string") {
      throw new ValidationError(
        "content",
        "Content parameter is required and must be a string",
      );
    }

    const config = this.createConfig(url, email);
    const client = this.getConfluenceClient(config);

    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "page_operation",
      status: "started",
      operation: "update",
      target: `page/${pageId}`,
    });

    // Create IO options with default timeout
    const ioOptions: IOOptions = {
      timeoutMs: args.timeoutMs,
    };

    const page = await client.getPage(pageId, ioOptions);

    const originalContent = page.body.storage.value;
    const updatedContent = DomAutoGeneratedHandler.replaceAutoGeneratedSection(
      originalContent,
      newContent,
    );

    logger.debug({
      event: "content_preparation",
      status: "completed",
      target: `page/${pageId}`,
      pageTitle: page.title,
      originalVersion: page.version.number,
      newContentLength: newContent.length,
    });

    const updatedPage = await client.updatePage(
      pageId,
      page.title,
      updatedContent,
      page.version.number,
      ioOptions,
    );

    logger.info({
      event: "page_operation",
      status: "completed",
      operation: "update",
      target: `page/${pageId}`,
      pageTitle: page.title,
      oldVersion: page.version.number,
      newVersion: updatedPage.version.number,
    });

    return {
      content: [
        {
          type: "text",
          text: `Successfully updated page "${page.title}".\\nNew version: ${updatedPage.version.number}\\nUpdated content: ${newContent}`,
        },
      ],
    };
  }

  /**
   * confluence_info ツールの処理
   */
  private async handleInfo(args: any): Promise<any> {
    const { url, email } = args;

    if (!url || typeof url !== "string") {
      throw new ValidationError(
        "url",
        "URL parameter is required and must be a string",
      );
    }

    const config = this.createConfig(url, email);
    const client = this.getConfluenceClient(config);

    const pageId = ConfluenceClient.extractPageIdFromUrl(url);

    logger.debug({
      event: "page_operation",
      status: "started",
      operation: "info",
      target: `page/${pageId}`,
    });

    // Create IO options with default timeout
    const ioOptions: IOOptions = {
      timeoutMs: args.timeoutMs,
    };

    const page = await client.getPage(pageId, ioOptions);
    const hasMarkers = DomAutoGeneratedHandler.hasAutoGeneratedMarkers(
      page.body.storage.value,
    );

    logger.info({
      event: "page_operation",
      status: "completed",
      operation: "info",
      target: `page/${pageId}`,
      pageTitle: page.title,
      version: page.version.number,
      hasMarkers,
    });

    return {
      content: [
        {
          type: "text",
          text: `Page Information:\\n  ID: ${page.id}\\n  Title: ${page.title}\\n  Version: ${page.version.number}\\n  Has auto-generated markers: ${hasMarkers}`,
        },
      ],
    };
  }

  /**
   * サーバーを開始
   */
  async start(): Promise<void> {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);

    logger.info({
      event: "server_lifecycle",
      status: "started",
      action: "startup",
      version: "1.0.0",
    });
  }
}

// メイン実行
async function main(): Promise<void> {
  const server = new ConfluenceMcpServer();
  await server.start();
}

// ES modules用のmain実行チェック
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error("Failed to start MCP server:", error);
    process.exit(1);
  });
}

export { ConfluenceMcpServer };
