import * as xml2js from "xml2js";
import type { AutoGeneratedSection } from "./types.js";

const BEGIN_MARKER = "BEGIN_AUTO_GENERATED";
const END_MARKER = "END_AUTO_GENERATED";

export class XmlAutoGeneratedHandler {
  private static parser = new xml2js.Parser({ 
    explicitArray: false,
    mergeAttrs: true,
    preserveChildrenOrder: true,
    explicitChildren: true,
    trim: false
  });
  
  private static builder = new xml2js.Builder({ 
    headless: true,
    renderOpts: { pretty: false }
  });

  /**
   * XML構造からBEGIN_AUTO_GENERATED/END_AUTO_GENERATED部分を抽出
   */
  static async extractAutoGeneratedSection(content: string): Promise<AutoGeneratedSection> {
    try {
      // まず文字列ベースで簡単にチェック
      const beginIndex = content.indexOf(BEGIN_MARKER);
      const endIndex = content.indexOf(END_MARKER);

      if (beginIndex === -1 || endIndex === -1) {
        return {
          before: content,
          content: "",
          after: "",
          found: false,
        };
      }

      // XMLとしてパース可能かチェック
      try {
        await this.parser.parseStringPromise(`<root>${content}</root>`);
        return await this.extractFromXml(content);
      } catch (xmlError) {
        // XMLパースが失敗した場合は文字列ベースで処理
        console.warn("XML parsing failed, falling back to string-based processing:", xmlError);
        return this.extractFromString(content);
      }
    } catch (error) {
      console.error("Error in extractAutoGeneratedSection:", error);
      return this.extractFromString(content);
    }
  }

  /**
   * XMLベースの抽出
   */
  private static async extractFromXml(content: string): Promise<AutoGeneratedSection> {
    const wrappedContent = `<root>${content}</root>`;
    const parsed = await this.parser.parseStringPromise(wrappedContent);
    
    // XML構造を文字列に戻してマーカーを探す
    const xmlString = this.builder.buildObject(parsed);
    const cleanContent = xmlString.replace(/^<root>|<\/root>$/g, '');
    
    return this.extractFromString(cleanContent);
  }

  /**
   * 文字列ベースの抽出（フォールバック）
   */
  private static extractFromString(content: string): AutoGeneratedSection {
    const beginIndex = content.indexOf(BEGIN_MARKER);
    const endIndex = content.indexOf(END_MARKER);

    if (beginIndex === -1 || endIndex === -1) {
      return {
        before: content,
        content: "",
        after: "",
        found: false,
      };
    }

    if (beginIndex >= endIndex) {
      throw new Error(
        "BEGIN_AUTO_GENERATED must appear before END_AUTO_GENERATED",
      );
    }

    const beginMarkerEnd = beginIndex + BEGIN_MARKER.length;
    const before = content.substring(0, beginIndex + BEGIN_MARKER.length);
    const autoGeneratedContent = content.substring(beginMarkerEnd, endIndex);
    const after = content.substring(endIndex);

    return {
      before,
      content: autoGeneratedContent,
      after,
      found: true,
    };
  }

  /**
   * 自動生成部分を新しいコンテンツで置き換え（改良版）
   */
  static async replaceAutoGeneratedSection(
    originalContent: string,
    newGeneratedContent: string,
  ): Promise<string> {
    const section = await this.extractAutoGeneratedSection(originalContent);

    if (!section.found) {
      // マーカーが見つからない場合は、適切なXML構造で追加
      return this.appendAutoGeneratedSection(originalContent, newGeneratedContent);
    }

    // マーカー間の内容を置き換え（構造を保持）
    return this.replaceWithProperStructure(section, newGeneratedContent);
  }

  /**
   * 適切なXML構造でマーカーセクションを追加
   */
  private static appendAutoGeneratedSection(originalContent: string, newContent: string): string {
    // 最後にpタグがある場合は、その前に挿入
    const lastPTagIndex = originalContent.lastIndexOf('</p>');
    
    if (lastPTagIndex !== -1) {
      const before = originalContent.substring(0, lastPTagIndex + 4);
      const after = originalContent.substring(lastPTagIndex + 4);
      
      return `${before}
<p><strong>${BEGIN_MARKER}</strong></p>
<p>${newContent}</p>
<p><strong>${END_MARKER}</strong></p>${after}`;
    }

    // 通常の追加
    return `${originalContent}
<p><strong>${BEGIN_MARKER}</strong></p>
<p>${newContent}</p>
<p><strong>${END_MARKER}</strong></p>`;
  }

  /**
   * 構造を保持しながら置き換え
   */
  private static replaceWithProperStructure(
    section: AutoGeneratedSection, 
    newContent: string
  ): string {
    // マーカー部分だけを置き換え、周囲の構造は保持
    const newSection = `
<p>${newContent}</p>
`;
    
    return `${section.before}${newSection}${section.after}`;
  }

  /**
   * 自動生成部分のみを取得
   */
  static async getAutoGeneratedContent(content: string): Promise<string> {
    const section = await this.extractAutoGeneratedSection(content);
    return section.content.trim();
  }

  /**
   * マーカーが存在するかチェック
   */
  static hasAutoGeneratedMarkers(content: string): boolean {
    return (
      content.includes(BEGIN_MARKER) && content.includes(END_MARKER)
    );
  }

  /**
   * マーカーを含む自動生成セクションを作成（構造化）
   */
  static createAutoGeneratedSection(content: string): string {
    return `<p><strong>${BEGIN_MARKER}</strong></p>
<p>${content}</p>
<p><strong>${END_MARKER}</strong></p>`;
  }
}
