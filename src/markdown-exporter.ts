import fs from "node:fs/promises";
import path from "node:path";
import { ConfluenceClient } from "./confluence-client.js";
import { DomAutoGeneratedHandler } from "./dom-auto-generated-handler.js";
import { logger } from "./logger.js";
import { MarkdownConverter } from "./markdown-converter.js";
import type {
  AttachmentInfo,
  ConfluenceConfig,
  ExportResult,
  IOOptions,
} from "./types.js";

/**
 * ConfluenceページをMarkdownファイルとしてエクスポート
 */
export class MarkdownExporter {
  private client: ConfluenceClient;
  private converter: MarkdownConverter;

  constructor(config: ConfluenceConfig) {
    this.client = new ConfluenceClient(config);
    this.converter = new MarkdownConverter();
  }

  /**
   * Confluenceページをエクスポート
   */
  async export(params: {
    pageUrl: string;
    outputDir: string;
    outputFileName?: string;
    options?: IOOptions;
  }): Promise<ExportResult> {
    const { pageUrl, outputDir, outputFileName, options } = params;

    logger.info({
      event: "markdown_export",
      status: "started",
      outputDir,
    });

    // 1. ページIDを取得
    const pageId = ConfluenceClient.extractPageIdFromUrl(pageUrl);

    // 2. ページを取得
    const page = await this.client.getPage(pageId, options);

    logger.info({
      event: "page_retrieved",
      pageId: page.id,
      pageTitle: page.title,
      version: page.version.number,
    });

    // 3. auto-generatedセクションを抽出
    const content = page.body.storage.value;
    const hasMarkers = DomAutoGeneratedHandler.hasAutoGeneratedMarkers(content);

    if (!hasMarkers) {
      logger.warn({
        event: "page_validation",
        issue: "no_auto_generated_markers",
        pageId: page.id,
      });
      throw new Error(
        `Page "${page.title}" does not contain auto-generated markers`,
      );
    }

    const autoGeneratedContent =
      DomAutoGeneratedHandler.getAutoGeneratedContent(content);

    // 4. 画像マクロを検出
    const imageRefs =
      this.converter.extractConfluenceImages(autoGeneratedContent);

    logger.debug({
      event: "image_extraction",
      count: imageRefs.length,
      images: imageRefs.map((ref) => ref.filename),
    });

    // 5. アタッチメント一覧を取得
    const attachments = await this.client.getAttachments(pageId, options);

    // 6. 画像の重複を排除
    const uniqueImages = new Map<string, AttachmentInfo>();
    for (const imageRef of imageRefs) {
      const attachment = attachments.find(
        (att) => att.title === imageRef.filename,
      );
      if (attachment && !uniqueImages.has(attachment.title)) {
        uniqueImages.set(attachment.title, attachment);
      }
    }

    logger.info({
      event: "image_deduplication",
      totalReferences: imageRefs.length,
      uniqueFiles: uniqueImages.size,
    });

    // 7. 画像をダウンロード（進捗表示）
    const downloadedImages: string[] = [];
    const imageMap = new Map<string, string>(); // filename -> localPath

    // 出力ディレクトリを作成
    await fs.mkdir(outputDir, { recursive: true });

    let downloadCount = 0;
    for (const [filename, attachment] of uniqueImages.entries()) {
      downloadCount++;

      logger.info({
        event: "image_download",
        status: "started",
        progress: `${downloadCount}/${uniqueImages.size}`,
        fileName: filename,
      });

      // 画像をダウンロード
      const imageData = await this.client.downloadAttachment(
        pageId,
        attachment.id,
        options,
      );

      // ファイルに保存
      const imagePath = path.join(outputDir, filename);
      await fs.writeFile(imagePath, imageData);

      downloadedImages.push(filename);
      imageMap.set(filename, filename); // 相対パス

      logger.info({
        event: "image_download",
        status: "completed",
        progress: `${downloadCount}/${uniqueImages.size}`,
        fileName: filename,
      });
    }

    // 8. 画像マクロを画像参照に置換（Markdown変換前に実行）
    const contentWithImageRefs =
      this.converter.replaceImageMacrosWithReferences(
        autoGeneratedContent,
        imageMap,
      );

    // 9. Markdownに変換
    const markdown = this.converter.toMarkdown(contentWithImageRefs);

    // 10. Markdownファイルを保存
    const fileName =
      outputFileName || `${this.sanitizeFileName(page.title)}.md`;
    const markdownPath = path.join(outputDir, fileName);
    await fs.writeFile(markdownPath, markdown, "utf-8");

    logger.info({
      event: "markdown_export",
      status: "completed",
      markdownFile: markdownPath,
      downloadedImages: downloadedImages.length,
    });

    return {
      success: true,
      markdownFile: markdownPath,
      downloadedImages,
      outputDir,
    };
  }

  /**
   * ファイル名をサニタイズ
   */
  private sanitizeFileName(fileName: string): string {
    // ファイル名に使えない文字を除去
    return fileName
      .replace(/[<>:"/\\|?*]/g, "-")
      .replace(/\s+/g, "-")
      .toLowerCase();
  }
}
