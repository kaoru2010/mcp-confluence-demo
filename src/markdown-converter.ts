import path from "node:path";
import * as cheerio from "cheerio";
import { marked } from "marked";
import TurndownService from "turndown";
import { gfm } from "turndown-plugin-gfm";
import type { ConfluenceImageReference, ImageReference } from "./types.js";

/**
 * ConfluenceのStorage FormatとMarkdownの相互変換
 */
export class MarkdownConverter {
  private turndownService: TurndownService;

  constructor() {
    this.turndownService = new TurndownService({
      headingStyle: "atx", // # スタイルのヘッディング
      codeBlockStyle: "fenced", // ```スタイルのコードブロック
      bulletListMarker: "-", // - でリスト
      emDelimiter: "*", // *italic*
      strongDelimiter: "**", // **bold**
    });

    // GitHub Flavored Markdownプラグインを使用（テーブルサポート）
    this.turndownService.use(gfm);

    // Confluenceの特殊な要素のカスタムルールを追加
    this.addConfluenceRules();
  }

  /**
   * Confluenceの特殊な要素に対するカスタムルールを追加
   */
  private addConfluenceRules(): void {
    // Confluenceのマクロは警告コメントとして変換
    this.turndownService.addRule("confluenceMacro", {
      filter: (node) => {
        return (
          node.nodeName === "AC:STRUCTURED-MACRO" ||
          node.nodeName === "AC:MACRO"
        );
      },
      replacement: (content, node) => {
        const element = node as unknown as {
          getAttribute?: (name: string) => string | null;
        };
        const macroName = element.getAttribute?.("ac:name") || "unknown";
        return `\n<!-- Confluence Macro: ${macroName} (not fully supported) -->\n${content}\n`;
      },
    });

    // Confluenceのリンク（ri:page）
    this.turndownService.addRule("confluencePageLink", {
      filter: (node) => {
        return (
          node.nodeName === "AC:LINK" &&
          node.querySelector("ri\\:page") !== null
        );
      },
      replacement: (content) => {
        return `[${content}](#confluence-page-link)`;
      },
    });

    // 注意: テーブルの処理はGFMプラグインに任せます
    // emptyTableCellのカスタムルールは削除しました
  }

  /**
   * Confluence Storage Format (XHTML) → Markdown
   */
  toMarkdown(storageFormat: string): string {
    try {
      // cheerioでHTMLをクリーンアップ
      const $ = cheerio.load(storageFormat, {
        xml: false,
      });

      // body部分のHTMLを取得（存在しない場合は全体を使用）
      const html = $("body").html() || storageFormat;

      // Markdownに変換
      const markdown = this.turndownService.turndown(html);

      // 余分な空行を整理
      return this.cleanupMarkdown(markdown);
    } catch (error) {
      throw new Error(
        `Failed to convert to Markdown: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Markdown → Confluence Storage Format (XHTML)
   */
  toStorageFormat(markdown: string): string {
    try {
      // MarkedでMarkdownをHTMLに変換
      const html = marked.parse(markdown, {
        async: false,
        gfm: true, // GitHub Flavored Markdown
        breaks: false, // 改行を<br>に変換しない
      }) as string;

      // ConfluenceのStorage Format用に調整
      return this.adjustForConfluence(html);
    } catch (error) {
      throw new Error(
        `Failed to convert from Markdown: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Markdownをクリーンアップ
   */
  private cleanupMarkdown(markdown: string): string {
    return `${markdown
      // 3行以上の連続した空行を2行に
      .replace(/\n{4,}/g, "\n\n\n")
      // 末尾の空白を削除
      .replace(/[ \t]+$/gm, "")
      // 最後に改行を1つ追加
      .trim()}\n`;
  }

  /**
   * HTMLをConfluenceのStorage Format用に調整
   */
  private adjustForConfluence(html: string): string {
    const $ = cheerio.load(html, {
      xml: false,
    });

    // Confluenceは一部のHTML要素をそのまま受け入れるが、調整が必要
    // 例: <p>タグは必須、<div>は避ける、など

    // bodyの中身だけを取得（markedが生成したHTMLをそのまま使用）
    let result = $.html();

    // 余分な<html><body>タグを削除
    result = result
      .replace(/^<html><head><\/head><body>/, "")
      .replace(/<\/body><\/html>$/, "");

    // Confluenceが受け入れやすいように調整
    // コードブロックの言語指定を調整（必要に応じて）
    result = result.replace(
      /<pre><code class="language-(\w+)">/g,
      '<ac:structured-macro ac:name="code"><ac:parameter ac:name="language">$1</ac:parameter><ac:plain-text-body><![CDATA[',
    );
    result = result.replace(
      /<\/code><\/pre>/g,
      "]]></ac:plain-text-body></ac:structured-macro>",
    );

    return result.trim();
  }

  /**
   * Confluence Storage Formatの自動生成部分をMarkdownに変換
   */
  convertAutoGeneratedToMarkdown(storageFormat: string): string {
    // 自動生成部分だけを抽出してMarkdownに変換
    // DomAutoGeneratedHandlerと組み合わせて使用することを想定
    return this.toMarkdown(storageFormat);
  }

  /**
   * MarkdownをConfluence Storage Formatの自動生成部分に変換
   */
  convertMarkdownToAutoGenerated(markdown: string): string {
    // Markdownを自動生成セクション用のStorage Formatに変換
    return this.toStorageFormat(markdown);
  }

  /**
   * Markdownから画像参照を抽出
   */
  extractImageReferences(markdown: string, baseDir: string): ImageReference[] {
    const references: ImageReference[] = [];

    // Markdown形式: ![alt](path)
    const markdownImageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
    let match: RegExpExecArray | null = null;

    match = markdownImageRegex.exec(markdown);
    while (match !== null) {
      const alt = match[1] || "";
      const imagePath = match[2];

      // URLは除外（http/httpsで始まる）
      if (imagePath && !/^https?:\/\//i.test(imagePath)) {
        references.push({
          originalPath: imagePath,
          resolvedPath: path.resolve(baseDir, imagePath),
          alt,
        });
      }
      match = markdownImageRegex.exec(markdown);
    }

    // HTML形式: <img src="path" ...>
    const htmlImageRegex = /<img\s+[^>]*src="([^"]+)"[^>]*>/gi;

    match = htmlImageRegex.exec(markdown);
    while (match !== null) {
      const imagePath = match[1];
      const fullMatch = match[0];

      // URLは除外
      if (imagePath && !/^https?:\/\//i.test(imagePath)) {
        // alt属性を抽出
        const altMatch = fullMatch.match(/alt="([^"]*)"/i);
        const alt = altMatch?.[1] || "";

        // width/height属性を抽出
        const widthMatch = fullMatch.match(/width="?(\d+)"?/i);
        const heightMatch = fullMatch.match(/height="?(\d+)"?/i);

        const attributes: { width?: number; height?: number } = {};
        if (widthMatch?.[1]) {
          attributes.width = Number.parseInt(widthMatch[1], 10);
        }
        if (heightMatch?.[1]) {
          attributes.height = Number.parseInt(heightMatch[1], 10);
        }

        references.push({
          originalPath: imagePath,
          resolvedPath: path.resolve(baseDir, imagePath),
          alt,
          ...(Object.keys(attributes).length > 0 && { attributes }),
        });
      }
      match = htmlImageRegex.exec(markdown);
    }

    return references;
  }

  /**
   * Storage Formatから画像参照を抽出
   */
  extractConfluenceImages(storageFormat: string): ConfluenceImageReference[] {
    const $ = cheerio.load(storageFormat, { xml: false });
    const references: ConfluenceImageReference[] = [];

    // ac:image マクロを探す
    $("ac\\:image").each((_, element) => {
      const $element = $(element);
      const $attachment = $element.find("ri\\:attachment");

      if ($attachment.length > 0) {
        const filename = $attachment.attr("ri:filename") || "";
        if (filename) {
          references.push({
            filename,
            downloadUrl: "", // ダウンロードURLは別途取得が必要
          });
        }
      }
    });

    return references;
  }

  /**
   * 画像参照をConfluenceマクロに置換（Markdown用・非推奨）
   * @deprecated Use replaceImageTagsWithMacros() instead
   */
  replaceImageReferencesWithMacros(
    markdown: string,
    imageMap: Map<string, string>, // originalPath -> attachmentFilename
  ): string {
    let result = markdown;

    // Markdown形式の画像を置換
    result = result.replace(
      /!\[([^\]]*)\]\(([^)]+)\)/g,
      (match, _alt, imagePath) => {
        if (!/^https?:\/\//i.test(imagePath)) {
          const filename = imageMap.get(imagePath);
          if (filename) {
            // Confluenceマクロに変換
            return `<ac:image><ri:attachment ri:filename="${filename}" /></ac:image>`;
          }
        }
        return match;
      },
    );

    // HTML形式の画像を置換
    result = result.replace(
      /<img\s+[^>]*src="([^"]+)"[^>]*>/gi,
      (match, imagePath) => {
        if (!/^https?:\/\//i.test(imagePath)) {
          const filename = imageMap.get(imagePath);
          if (filename) {
            // width/height属性を抽出
            const widthMatch = match.match(/width="?(\d+)"?/i);
            const heightMatch = match.match(/height="?(\d+)"?/i);

            let macro = "<ac:image>";
            if (widthMatch || heightMatch) {
              macro = `<ac:image ac:width="${widthMatch?.[1] || ""}"`;
              if (heightMatch) {
                macro += ` ac:height="${heightMatch[1]}"`;
              }
              macro += ">";
            }
            macro += `<ri:attachment ri:filename="${filename}" /></ac:image>`;
            return macro;
          }
        }
        return match;
      },
    );

    return result;
  }

  /**
   * HTML内の<img>タグを画像マクロに置換（Storage Format用）
   */
  replaceImageTagsWithMacros(
    html: string,
    imageMap: Map<string, string>, // originalPath -> attachmentFilename
  ): string {
    const $ = cheerio.load(html, { xml: false });

    // <img>タグを探して置換
    $("img").each((_, element) => {
      const $img = $(element);
      const src = $img.attr("src");

      if (src && !/^https?:\/\//i.test(src)) {
        const filename = imageMap.get(src);

        if (filename) {
          // width/height属性を取得
          const width = $img.attr("width");
          const height = $img.attr("height");

          // Confluenceマクロを作成
          let macro = "<ac:image";
          if (width) {
            macro += ` ac:width="${width}"`;
          }
          if (height) {
            macro += ` ac:height="${height}"`;
          }
          macro += `><ri:attachment ri:filename="${filename}" /></ac:image>`;

          // <img>タグを置換
          $img.replaceWith(macro);
        }
      }
    });

    return $.html();
  }

  /**
   * Confluenceマクロを画像参照に置換
   */
  replaceImageMacrosWithReferences(
    storageFormat: string,
    imageMap: Map<string, string>, // attachmentFilename -> localPath
  ): string {
    const $ = cheerio.load(storageFormat, { xml: false });

    // ac:image マクロを探して置換
    $("ac\\:image").each((_, element) => {
      const $element = $(element);
      const $attachment = $element.find("ri\\:attachment");

      if ($attachment.length > 0) {
        const filename = $attachment.attr("ri:filename") || "";
        const localPath = imageMap.get(filename);

        if (localPath) {
          // width/height属性を確認
          const width = $element.attr("ac:width");
          const height = $element.attr("ac:height");

          // すべてHTML <img>タグに置換（TurndownServiceがMarkdownに変換）
          let replacement = `<img src="${localPath}" alt="${filename}"`;
          if (width) replacement += ` width="${width}"`;
          if (height) replacement += ` height="${height}"`;
          replacement += ">";

          $element.replaceWith(replacement);
        }
      }
    });

    return $.html();
  }
}

// シングルトンインスタンスをエクスポート
export const markdownConverter = new MarkdownConverter();
