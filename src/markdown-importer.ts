import fs from "node:fs/promises";
import path from "node:path";
import { ConfluenceClient } from "./confluence-client.js";
import { DomAutoGeneratedHandler } from "./dom-auto-generated-handler.js";
import { ValidationError as DomainValidationError } from "./errors.js";
import { logger } from "./logger.js";
import { MarkdownConverter } from "./markdown-converter.js";
import type {
  ConfluenceConfig,
  ImageReference,
  ImportResult,
  IOOptions,
  ValidationError,
  ValidationResult,
} from "./types.js";

// 最大ファイルサイズ (10MB)
const MAX_FILE_SIZE = 10 * 1024 * 1024;

/**
 * MarkdownファイルをConfluenceにインポート
 */
export class MarkdownImporter {
  private client: ConfluenceClient;
  private converter: MarkdownConverter;

  constructor(config: ConfluenceConfig) {
    this.client = new ConfluenceClient(config);
    this.converter = new MarkdownConverter();
  }

  /**
   * Markdownファイルをインポート
   */
  async import(params: {
    markdownFilePath: string;
    pageUrl: string;
    options?: IOOptions;
  }): Promise<ImportResult> {
    const { markdownFilePath, pageUrl, options } = params;

    logger.info({
      event: "markdown_import",
      status: "started",
      markdownFile: markdownFilePath,
    });

    // 1. Markdownファイルを読み込み
    const markdown = await fs.readFile(markdownFilePath, "utf-8");
    const baseDir = path.dirname(path.resolve(markdownFilePath));

    // 2. 画像参照を抽出
    const imageRefs = this.converter.extractImageReferences(markdown, baseDir);
    logger.debug({
      event: "image_extraction",
      count: imageRefs.length,
      images: imageRefs.map((ref) => ref.originalPath),
    });

    // 3. 事前検証
    const validation = await this.validateImages(imageRefs);
    if (!validation.valid) {
      const errorMessages = validation.errors.map((e) => e.message).join(", ");
      throw new DomainValidationError(
        "images",
        `Image validation failed: ${errorMessages}`,
      );
    }

    // 4. 重複を排除（同じファイルは1回だけアップロード）
    const uniqueImages = this.deduplicateImages(imageRefs);

    logger.info({
      event: "image_deduplication",
      totalReferences: imageRefs.length,
      uniqueFiles: uniqueImages.size,
    });

    // 5. ページIDを取得
    const pageId = ConfluenceClient.extractPageIdFromUrl(pageUrl);

    // 6. ページを取得
    const page = await this.client.getPage(pageId, options);

    logger.info({
      event: "page_retrieved",
      pageId: page.id,
      pageTitle: page.title,
      version: page.version.number,
    });

    // 7. 画像をアップロード（進捗表示）
    const uploadedImages: string[] = [];
    let uploadCount = 0;

    for (const [resolvedPath, _imageRef] of uniqueImages.entries()) {
      uploadCount++;
      const fileName = path.basename(resolvedPath);

      logger.info({
        event: "image_upload",
        status: "started",
        progress: `${uploadCount}/${uniqueImages.size}`,
        fileName,
      });

      const fileData = await fs.readFile(resolvedPath);
      const contentType = this.getContentType(fileName);

      await this.client.uploadAttachment(
        pageId,
        fileName,
        fileData,
        contentType,
        options,
      );

      uploadedImages.push(fileName);

      logger.info({
        event: "image_upload",
        status: "completed",
        progress: `${uploadCount}/${uniqueImages.size}`,
        fileName,
      });
    }

    // 8. MarkdownをStorage Formatに変換
    const storageContent = this.converter.toStorageFormat(markdown);

    // 9. 画像パスをファイル名にマッピング
    const imageMap = new Map<string, string>();
    for (const ref of imageRefs) {
      imageMap.set(ref.originalPath, path.basename(ref.resolvedPath));
    }

    // 10. HTML内の<img>タグを画像マクロに置換
    const storageContentWithMacros = this.converter.replaceImageTagsWithMacros(
      storageContent,
      imageMap,
    );

    // 11. ページを更新
    const originalContent = page.body.storage.value;
    const updatedContent = DomAutoGeneratedHandler.replaceAutoGeneratedSection(
      originalContent,
      storageContentWithMacros,
    );

    logger.debug({
      event: "page_update",
      status: "started",
      pageId: page.id,
    });

    const updatedPage = await this.client.updatePage(
      pageId,
      page.title,
      updatedContent,
      page.version.number,
      options,
    );

    logger.info({
      event: "markdown_import",
      status: "completed",
      pageId: updatedPage.id,
      pageTitle: updatedPage.title,
      oldVersion: page.version.number,
      newVersion: updatedPage.version.number,
      uploadedImages: uploadedImages.length,
    });

    return {
      success: true,
      pageId: updatedPage.id,
      pageTitle: updatedPage.title,
      pageVersion: updatedPage.version.number,
      uploadedImages,
    };
  }

  /**
   * 画像ファイルの検証
   */
  private async validateImages(
    imageRefs: ImageReference[],
  ): Promise<ValidationResult> {
    const errors: ValidationError[] = [];

    for (const ref of imageRefs) {
      try {
        const stats = await fs.stat(ref.resolvedPath);

        // ファイルサイズチェック
        if (stats.size > MAX_FILE_SIZE) {
          errors.push({
            type: "size_limit",
            path: ref.originalPath,
            message: `File too large: ${ref.originalPath} (${stats.size} bytes, max: ${MAX_FILE_SIZE})`,
          });
        }

        // ファイルタイプチェック（画像ファイルのみ）
        const ext = path.extname(ref.resolvedPath).toLowerCase();
        const validExtensions = [
          ".png",
          ".jpg",
          ".jpeg",
          ".gif",
          ".svg",
          ".webp",
        ];
        if (!validExtensions.includes(ext)) {
          errors.push({
            type: "invalid_type",
            path: ref.originalPath,
            message: `Invalid file type: ${ref.originalPath} (expected: ${validExtensions.join(", ")})`,
          });
        }
      } catch (_error) {
        errors.push({
          type: "not_found",
          path: ref.originalPath,
          message: `File not found: ${ref.originalPath} (resolved: ${ref.resolvedPath})`,
        });
      }
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * 画像の重複を排除
   */
  private deduplicateImages(
    imageRefs: ImageReference[],
  ): Map<string, ImageReference> {
    const uniqueMap = new Map<string, ImageReference>();

    for (const ref of imageRefs) {
      if (!uniqueMap.has(ref.resolvedPath)) {
        uniqueMap.set(ref.resolvedPath, ref);
      }
    }

    return uniqueMap;
  }

  /**
   * ファイル名からMIMEタイプを取得
   */
  private getContentType(fileName: string): string {
    const ext = path.extname(fileName).toLowerCase();
    const mimeTypes: Record<string, string> = {
      ".png": "image/png",
      ".jpg": "image/jpeg",
      ".jpeg": "image/jpeg",
      ".gif": "image/gif",
      ".svg": "image/svg+xml",
      ".webp": "image/webp",
    };
    return mimeTypes[ext] || "application/octet-stream";
  }
}
